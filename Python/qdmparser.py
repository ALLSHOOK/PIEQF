#!/usr/bin/python

###
# Parkfield Interventional Earth-Quake Fieldwork
# 
# Defines classes for parsing a QDM 'merged XML catalog' of earthquakes,
# and for 'triggering' a callback function for each new event appearing in this catalog.
# The 'backlisting' of events to be ignored in future is also supported, 
# and the 'blacklist' is saved to disk (as XML)
#
#	Stock, V2_Lab Rotterdam, June 2008
###
from __future__ import with_statement

import os, errno, types, time, stat
import threading, signal

import xml.parsers.expat
from xml.dom import minidom, DOMException

class ParserError(BaseException):
	pass


class QDMParser(object):
	"""Class to read and parse the earthquake-catalog XML-file generated by
	the QDDS & QDM programs.
	"""
	# where to read the XML Earthquake catalog from
	inputfile = "/var/lib/QDM/catalog/merge.xml"
	# where to store the 'blacklist' of events to be omitted from the db
	blacklistfile = "/var/lib/QDM/catalog/blacklist.xml"
	# the USGS Network-ID's of the regions we're interested in
	#networks = [u'CI', u'NC', u'NN']
	networks = [u'CI', u'NC']
	# the database (dict) with the parsed quakes
	db = {}
	# the database (dict) with events to be ignored
	blacklist = {}
	
	def __init__(self, inputfile=None, blacklistfile=None):
		"""Instantiate a parser
		If 'inputfile' is not given, the default file '/var/lib/QDM/catalog/merge.xml' is used
		If 'blacklistfile' is not given, the default file '/var/lib/QDM/catalog/blacklist.xml' is used
		The parsed quakes are stored in a dict, indexed by magnitude
		The dict is accessible as QDMParser.db
		"""
		
		if type(inputfile) in types.StringTypes:
			self.inputfile = inputfile
			
		if not os.path.isfile(self.inputfile):
			raise OSError((errno.ENOENT, "File not found: '%s'" % self.inputfile))
		
		if type(blacklistfile) in types.StringTypes:
			self.blacklistfile = blacklistfile
			
		self.event = None
		self.mtime = 0
		
		self.parser_thread = None
		self.parser_lock = threading.Lock()
		self.parsed = threading.Event()
		self.run = False
		
		self._loadBlackList()

		
	def __str__(self):
		"""Returns the current database as a multi-line string
		"""
		out = ""
		with self.parser_lock:
			for mag in sorted(self.db.keys()):
				ev = self.db[mag]
				out += "%s\n" % self._eventStr(ev)
			
		return out
	
	def _eventStr(self, ev):
		"""Returns a one-line string with the given event's metadata
		"""
		timestring = time.strftime("%b %d %Y - %H:%M:%S UTC", time.localtime(ev['time']))
		out = "%.1f \t %s \t %s:%s \t %8.3f, %8.3f" % (ev['mag'], timestring, ev['net'], ev['id'], ev['loc'][0], ev['loc'][1])
		if 'depth' in ev:
			out += " \t %5.1f km" % ev['depth']
		else:
			out += " \t        "
		if 'dmin' in ev:
			out += " \t %5.1f km" % ev['dmin']
	
		return out
	
	
	def _loadBlackList(self):
		"""Loads and parses the blacklist-file (XML)
		stores the blacklisted events in a dict (self.blacklist) indexed by Event-ID
		"""
		if os.path.isfile(self.blacklistfile):
			self.blacklistdom = minidom.parse(self.blacklistfile)
		else:
			xml = '<?xml version="1.0" encoding="UTF-8"?><ignore></ignore>'
			self.blacklistdom = minidom.parseString(xml)
			self._saveBlackList()
			
		with self.parser_lock:
			self.blacklist = {}
			for ev in self.blacklistdom.getElementsByTagName('event'):
				event = {}
				event['id'] = str(ev.getAttribute('id'))
				event['net'] = str(ev.getAttribute('network-code'))
				event['why'] = str(ev.getAttribute('reason'))
				self.blacklist[event['id']] = event
	
	def _saveBlackList(self):
		"""Writes the blacklist-DOM currently held in memory back to the blaclist-file
		"""
		try:
			f = open(self.blacklistfile, 'w')
			lines = self.blacklistdom.toprettyxml().splitlines()
			for l in lines:
				l = l.rstrip()
				if not len(l):
					continue
				f.write("%s\n" % l)
		finally:
			f.close()
		
		
	def parse(self):
		"""Parse the XML catalog-file
		updates the databse (a dict of recent events, indexed by (magnitude * 10))
		"""
		self.xp = xml.parsers.expat.ParserCreate()
		
		self.xp.StartElementHandler = self._StartElementHandler
		self.xp.EndElementHandler = self._EndElementHandler
		
		try:
			self.mtime = os.stat(self.inputfile)[stat.ST_MTIME]
			f = open(self.inputfile)
			
			with self.parser_lock:
				self.db = {}
				self.xp.ParseFile(f)
			
			self.parsed.set()
		
		except xml.parsers.expat.ExpatError:
			eno = self.xp.ErrorCode
			lno = self.xp.ErrorLineNumber
			raise ParserError("XML Error [%d] in '%s' line %d: %s" % (eno, self.inputfile, lno, xml.parsers.expat.ErrorString(eno)))
		
		finally:
			f.close()
				
				
	def _StartElementHandler(self, name, attribute):
		"""This method is called by the Expat-parser at the start of each XML-element
		"""
		if name == u'event':
			# only parse events for the Networks we want
			try:
				netcode = str(attribute[u'network-code']).upper()
				id = str(attribute[u'id'])
				if (netcode in self.networks) and (id not in self.blacklist):
					self.event = {'net':netcode, 'id': id}
			except KeyError, e:
				raise ParserError("Missing attribute in <event ...>: %s" % str(e))
						
		# parse relevant event-paramters (event time & magnitude)
		elif name == u'param' and self.event != None:
			try:
				if attribute[u'name'] == u'year':
					self.event['year'] = int(attribute[u'value'])
				elif attribute[u'name'] == u'month':
					self.event['month'] = int(attribute[u'value'])
				elif attribute[u'name'] == u'day':
					self.event['day'] = int(attribute[u'value'])
				elif attribute[u'name'] == u'hour':
					self.event['hour'] = int(attribute[u'value'])
				elif attribute[u'name'] == u'minute':
					self.event['min'] = int(attribute[u'value'])
				elif attribute[u'name'] == u'second':
					self.event['sec'] = float(attribute[u'value'])
				elif attribute[u'name'] == u'magnitude':
					self.event['mag'] = float(attribute[u'value'])
				elif attribute[u'name'] == u'latitude':
					self.event['lat'] = float(attribute[u'value'])
				elif attribute[u'name'] == u'longitude':
					self.event['lon'] = float(attribute[u'value'])
				elif attribute[u'name'] == u'depth':
					self.event['depth'] = float(attribute[u'value'])
				elif attribute[u'name'] == u'dist-first-station':
					self.event['dmin'] = float(attribute[u'value'])
			except KeyError, e:
				raise ParserError('Missing <param ...> in <event "%s">: %s' % (self.event['id'], str(e)))
		
	def _EndElementHandler(self, name):
		"""This method is called by the Expat-parser at the end of each XML-element
		"""
		if (name == u'event') and (self.event != None):
			ev = {}
			# Calculate time in Python-native format (floating-point seconds since the Epoch)
			ev['time'] = time.mktime((self.event['year'], self.event['month'], self.event['day'], self.event['hour'], \
					self.event['min'], int(self.event['sec']), 0, 0, -1)) + (self.event['sec'] % 1)
			
			# transfer other relevant parameters
			ev['net'] = self.event['net']
			ev['id'] = self.event['id']
			ev['loc'] = [self.event['lat'], self.event['lon']]
			ev['mag'] = self.event['mag']
			if 'depth' in self.event:
				ev['depth'] = self.event['depth']
			if 'dmin' in self.event:
				ev['dmin'] = self.event['dmin']
			
			mag = int(self.event['mag'] * 10.)
			
			# Store event in DB If this Magnitude does not exist in DB
			if mag not in self.db:
				self.db[mag] = ev
			
			# Store event in DB If this Magnitude exists in DB, but current event is more recent
			elif ev['time'] > self.db[mag]['time']:
				self.db[mag] = ev
			
			self.event = None
		
	def wait(self, timeout=None):
		"""Waits for the end of the next parser-run
		If 'timeout' == None, it waits indefinately.
		"""
		self.parsed.clear()
		self.parsed.wait(timeout)
		
	def isReady(self):
		"""Returns 'True' if the parser-run is done, and no other processes are waiting for the next parser-run
		"""
		return self.parsed.isSet()
	
	def getAll(self):
		"""Returns a list of all Events currently in the DB (a list of dicts)
		"""
		with self.parser_lock:
			return self.db.values()
		
	def getAllIds(self):
		"""Returns a list with the Event-ID's of all events currently in the DB (a list of strings)
		"""
		ids = []
		for ev in self.getAll():
			ids.append(ev['id'])
			
		return ids
		
		
	def getEvent(self, magnitude):
		"""Returns the event (as a dict) from the DB with a magnitude matching the given magnitude,
		if this exists. Returns the event with the nearest smaller magnitude otherwise
		"""
		with self.parser_lock:
			maglist = sorted(self.db.keys())
		
			mag = int(magnitude * 10.)
			ret = None
			for m in reversed(range(mag)):
				if m in maglist:
					ret = self.db[m]
					break
				
		return ret
			
	def getEventStr(self, magnitude):
		"""Returns the event (as a one-line string) from the DB with a magnitude matching the given magnitude,
		if this exists. Returns the event with the nearest smaller magnitude otherwise
		"""
		ev = self.getEvent(magnitude)
		return self._eventStr(ev)
		
	
	def _setAttribute(self, e, name, value) :
		"""Creates or replaces an attribute with specified name and value (string or int)
		to specified DOMElement"""
		a = self.blacklistdom.createAttribute(name)
		e.setAttributeNode(a)
		e.setAttribute(name, unicode(value))

	def blackListEvent(self, event, reason=None):
		"""Adds the given event to the current blacklist-DOM
		Saves and Re-loads the blacklist-file
		If 'reason' is not given, but a 'reason' element exists in the given event, that reason is used
		"""
		ign = self.blacklistdom.getElementsByTagName('ignore')[0]
		ev = self.blacklistdom.createElement('event')
		self._setAttribute(ev, 'id', event['id'])
		self._setAttribute(ev, 'network-code', event['net'])
		if reason:
			self._setAttribute(ev, 'reason', reason)
		elif 'reason' in event:
			self._setAttribute(ev, 'reason', event['reason'])
		ign.appendChild(ev)
		self._saveBlackList()
		self._loadBlackList()
	
	def unblackListEvent(self, event):
		"""Removes the given event from the current blacklist-DOM
		Saves and Re-loads the blacklist-file
		"""
		ign = self.blacklistdom.getElementsByTagName('ignore')[0]
		for ev in ign.getElementsByTagName('event'):
			id = str(ev.getAttribute('id'))
			net = str(ev.getAttribute('network-code'))
			if (id == event['id']) and (net == event['net']):
				ign.removeChild(ev)
				ev.unlink()
				break
		else:	# event not found in blacklistdom
			return
		
		self._saveBlackList()
		self._loadBlackList()
	
	
	def _parseForever(self):
		"""A 'MainLoop' function:
		Checks every second if the inputfile '%s' has been modified.
		If it has, parses the file and rebuilds the DB
		""" % self.inputfile
		while self.run:
			try:
				if os.stat(self.inputfile)[stat.ST_MTIME] > self.mtime:
					self.parse()
					continue
			except OSError:
				pass
			
			time.sleep(1)
		
	def start(self):
		"""Starts the parser's MainLoop in a new thread.
		"""
		self.run = True
		self.parser_thread = threading.Thread(None, self._parseForever, "QDMParserThread")
		self.parser_thread.start()
		
	def stop(self):
		"""Stops the parser's MainLoop and waits for its thread to finish.
		"""
		self.run = False
		
		if isinstance(self.parser_thread, threading.Thread):
			self.parser_thread.join()
			self.parser_thread = None
		
	def reload(self):
		"""Force a reload of the blacklistfile and parse the inputfile
		"""
		self._loadBlackList()
		self.parse()
	

class QDMTrigger(QDMParser):
	"""An extended QDMParser which features a trigger-function that is called
	for each new event appearing in the DB
	"""
	def __init__(self, inputfile=None, blacklistfile=None):
		"""Instantiate a parser/trigger
		If 'inputfile' is not given, the default file '/var/lib/QDM/catalog/merge.xml' is used
		If 'blacklistfile' is not given, the default file '/var/lib/QDM/catalog/blacklist.xml' is used
		The parsed quakes are stored in a dict, indexed by magnitude
		The dict is accessible as QDMTrigger.db
		"""
		
		super(self.__class__, self).__init__(inputfile, blacklistfile)
		
		self.trigger_thread = None
		self.triggered = threading.Event()
		
	def start(self):
		"""Starts the parser's MainLoop and the TriggerLoop each in a new thread.
		"""
		super(self.__class__, self).start()
		
		self.trigger_thread = threading.Thread(None, self._triggerLoop, "QDMTriggerThread")
		self.trigger_thread.start()
		
	def stop(self):
		"""Stops the parser's MainLoop and waits for its thread to finish.
		Stops the parser's TriggerLoop and waits for its thread to finish.
		"""
		super(self.__class__, self).stop()
		
		if isinstance(self.trigger_thread, threading.Thread):
			self.trigger_thread.join()
			self.trigger_thread = None


	def _triggerLoop(self):
		"""The MainLoop for the trigger:
		Waits for each parser-run to finish.
		Checks the updated DB against a list of previously-seen Event-IDs.
		For each new event (i.e. in the updated DB, but not in the list of previous events)
		the trigger-function is called with a list of new events (as dicts) as argument.
		"""
		old = []
		while self.run:
			self.wait(1)
			if not self.isReady():
				continue
			
			new = []
			current = []
			events = self.getAll()
			for ev in events:
				if ev['id'] not in old:
					new.append(ev)
					
				current.append(ev['id'])

			if len(new) and len(old):
				self.triggered.set()
				self.trig_func(new)
			
			old = current
				
		
	def waitTrig(self, timeout=None):
		"""Waits for a trigger (i.e. new event in the DB) to occur.
		If 'timeout' == None, it waits indefinately
		"""
		self.triggered.clear()
		self.triggered.wait(timeout)
	
	def hasTrigger(self):
		"""Returns 'True' if a Trigger has occured, and no other processes are waiting for the next Trigger
		"""
		return self.trigger.isSet()
	
	def trig_func(self, events):
		"""A simple (example) trigger-function:
		Prints 'Triggered for new event: ' + a string-version of the event, for each new event
		Alternative implementations must accept one argument; a list of events (list of dicts)
		"""
		for ev in events:
			print "Triggered for new event: %s" % self._eventStr(ev)

	def setTrigFunc(self, func):
		"""Register a trigger-function.
		Checks if the supplied argument is callable (ie. a method or function) and accepts the correct number of arguments.
		"""
		if hasattr(func, 'im_func'):
			if func.im_func.func_code.co_argcount != 2:
				raise AttributeError("Trigger callback function '%s' must take 2 arguments (self, events)" % repr(func))
		elif hasattr(func, 'func_code'):
			if func.func_code.co_argcount != 1:
				raise AttributeError("Trigger callback function '%s' must take 1 arguments (events)" % repr(func))
		else:
			raise TypeError("Trigger callback function '%s' is not callable" % repr(func))
		
		self.trig_func = func
	


if __name__ == '__main__':
	from optparse import OptionParser
	
	op = OptionParser()
	
	# Define command-line options
	op.add_option("-p", "--parse-forever", action='store_true', dest='parse', help="run parser-thread in background (forever)")
	op.add_option("-t", "--trig-forever", action='store_true', dest='trig', help="run trigger-thread in background (forever)")
	
	# Parse Command-line options
	(opts, args) = op.parse_args()
	
	# Choose 'operating mode'
	if opts.trig:
		qp = QDMTrigger()
	else:
		qp = QDMParser()
	
	# Defina a function that ptints the current DB
	def printlist():
		timestring = time.strftime("%b %d %Y - %H:%M:%S UTC", time.gmtime(qp.mtime))
		print "on \t %s: %d Events" % (timestring, len(qp.db))
		print "Mag \t Date          Time \t\tNet:ID \t\t Lati      Long \t Depth \t\t Dmin"
		print qp
		
	
	if not (opts.parse or opts.trig):
		# Run once. Print DB, then exit
		qp.parse()
		printlist()
		exit(0)
	
	# Start the Parser-thread (and possibly the Trigger-thread)
	qp.start()
	
	# Define a signal-handler to stop the Parser-thread (and possibly the Trogger-thread)
	def stophandler(sig, frame):
		print "\nGot signal %d" % sig
		qp.stop()
	
	# Define a signa-handler to relaod the blacklist-file and re-parse the DB
	def reloadhandler(sig, frame):
		print "\nGot signal %d" % sig
		qp.reload()
	
	# Register signal-handlers
	signal.signal(signal.SIGINT, stophandler)
	signal.signal(signal.SIGQUIT, stophandler)
	signal.signal(signal.SIGHUP, reloadhandler)
	
	# Define a trigger-function
	def trig_func(events):
		for ev in events:
			timestring = time.strftime("%b %d %Y - %H:%M:%S UTC", time.localtime(ev['time']))
			print "Triggered for new event: %s:%s M% 4.1f at %s" % (ev['net'], ev['id'], ev['mag'], timestring)
	
	try:
		if opts.parse:
			# wait fro the parser-run to finish, then print the DB. Repeat.
			while qp.run:
				qp.wait(1)
				
				if qp.isReady():
					printlist()
					
		elif opts.trig:
			# Register our trigger-functopn
			qp.setTrigFunc(trig_func)
			
			# wait forever until qp is stopped or an exception occurs
			while qp.run:
				qp.waitTrig(1)
	
	finally:
		print "Quitting"
		if qp.run:
			qp.stop()
		exit(0)